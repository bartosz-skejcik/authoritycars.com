create table "public"."audit_logs" (
    "id" bigint generated by default as identity not null,
    "timestamp" timestamp with time zone not null default now(),
    "action" character varying not null,
    "user_id" uuid,
    "entity_id" text,
    "entity_type" text,
    "old_values" jsonb,
    "new_values" jsonb,
    "ip_address" text,
    "user_agent" text,
    "submitter_name" text
);


create table "public"."profiles" (
    "id" uuid not null,
    "updated_at" timestamp with time zone,
    "username" text,
    "full_name" text,
    "avatar_url" text,
    "website" text
);


alter table "public"."profiles" enable row level security;

create table "public"."statuses" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" character varying not null
);


create table "public"."submission_tags" (
    "submission_id" integer not null,
    "tag_id" integer not null
);


create table "public"."submissions" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "phone" character varying not null,
    "name" character varying not null,
    "budget_from" real not null,
    "budget_to" real not null,
    "vehicle_type" character varying not null,
    "status_id" bigint,
    "assigned_user_id" uuid,
    "ref" character varying
);


create table "public"."tags" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" character varying not null,
    "hex" character varying not null default '#f00'::character varying
);


CREATE UNIQUE INDEX audit_logs_pkey ON public.audit_logs USING btree (id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX profiles_username_key ON public.profiles USING btree (username);

CREATE UNIQUE INDEX statuses_name_key ON public.statuses USING btree (name);

CREATE UNIQUE INDEX statuses_pkey ON public.statuses USING btree (id);

CREATE UNIQUE INDEX submission_tags_pkey ON public.submission_tags USING btree (submission_id, tag_id);

CREATE UNIQUE INDEX submissions_phone_key ON public.submissions USING btree (phone);

CREATE UNIQUE INDEX submissions_pkey ON public.submissions USING btree (id);

CREATE UNIQUE INDEX tags_pkey ON public.tags USING btree (id);

alter table "public"."audit_logs" add constraint "audit_logs_pkey" PRIMARY KEY using index "audit_logs_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."statuses" add constraint "statuses_pkey" PRIMARY KEY using index "statuses_pkey";

alter table "public"."submission_tags" add constraint "submission_tags_pkey" PRIMARY KEY using index "submission_tags_pkey";

alter table "public"."submissions" add constraint "submissions_pkey" PRIMARY KEY using index "submissions_pkey";

alter table "public"."tags" add constraint "tags_pkey" PRIMARY KEY using index "tags_pkey";

alter table "public"."audit_logs" add constraint "audit_logs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."audit_logs" validate constraint "audit_logs_user_id_fkey";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."profiles" add constraint "profiles_username_key" UNIQUE using index "profiles_username_key";

alter table "public"."profiles" add constraint "username_length" CHECK ((char_length(username) >= 3)) not valid;

alter table "public"."profiles" validate constraint "username_length";

alter table "public"."statuses" add constraint "statuses_name_key" UNIQUE using index "statuses_name_key";

alter table "public"."submission_tags" add constraint "submission_tags_submission_id_fkey" FOREIGN KEY (submission_id) REFERENCES submissions(id) ON DELETE CASCADE not valid;

alter table "public"."submission_tags" validate constraint "submission_tags_submission_id_fkey";

alter table "public"."submission_tags" add constraint "submission_tags_tag_id_fkey" FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE not valid;

alter table "public"."submission_tags" validate constraint "submission_tags_tag_id_fkey";

alter table "public"."submissions" add constraint "submissions_assigned_user_id_fkey" FOREIGN KEY (assigned_user_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."submissions" validate constraint "submissions_assigned_user_id_fkey";

alter table "public"."submissions" add constraint "submissions_phone_key" UNIQUE using index "submissions_phone_key";

alter table "public"."submissions" add constraint "submissions_status_id_fkey" FOREIGN KEY (status_id) REFERENCES statuses(id) ON UPDATE CASCADE ON DELETE SET DEFAULT not valid;

alter table "public"."submissions" validate constraint "submissions_status_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_audit_log(action text, entity_id text DEFAULT NULL::text, entity_type text DEFAULT NULL::text, old_values jsonb DEFAULT NULL::jsonb, new_values jsonb DEFAULT NULL::jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  user_id UUID := public.get_auth_user_id();
BEGIN
  INSERT INTO public.audit_logs (
    action,
    user_id,
    entity_id,
    entity_type,
    old_values,
    new_values,
    ip_address,
    user_agent
  )
  VALUES (
    action,
    user_id,
    entity_id,
    entity_type,
    old_values,
    new_values,
    NULLIF(current_setting('request.headers.x-forwarded-for', true), ''),
    NULLIF(current_setting('request.headers.user-agent', true), '')
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_auth_user_id()
 RETURNS uuid
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
  SELECT NULLIF(COALESCE(
    current_setting('request.jwt.claims', true)::json->>'sub', 
    current_setting('request.headers.x-user-id', true)
  ), '')::uuid;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.log_profile_changes()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  user_id UUID := public.get_auth_user_id();
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_logs (action, user_id, entity_id, entity_type, new_values)
    VALUES (
      'profile_created', 
      COALESCE(user_id, NEW.id), -- If no user_id, use profile id itself (self-registration)
      NEW.id::text,
      'profile',
      jsonb_build_object(
        'username', NEW.username,
        'full_name', NEW.full_name
      )
    );
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    -- Only log if there are actual changes
    IF NEW.username IS DISTINCT FROM OLD.username OR 
       NEW.full_name IS DISTINCT FROM OLD.full_name OR 
       NEW.website IS DISTINCT FROM OLD.website OR 
       NEW.avatar_url IS DISTINCT FROM OLD.avatar_url THEN
      INSERT INTO public.audit_logs (
        action, user_id, entity_id, entity_type, old_values, new_values
      )
      VALUES (
        'profile_updated', 
        COALESCE(user_id, NEW.id), -- If no user_id, assume self-update
        NEW.id::text,
        'profile',
        jsonb_build_object(
          'username', OLD.username,
          'full_name', OLD.full_name,
          'website', OLD.website,
          'avatar_url', OLD.avatar_url
        ),
        jsonb_build_object(
          'username', NEW.username,
          'full_name', NEW.full_name,
          'website', NEW.website,
          'avatar_url', NEW.avatar_url
        )
      );
    END IF;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_logs (action, user_id, entity_id, entity_type, old_values)
    VALUES (
      'profile_deleted', 
      COALESCE(user_id, OLD.id),
      OLD.id::text,
      'profile',
      jsonb_build_object(
        'username', OLD.username,
        'full_name', OLD.full_name
      )
    );
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_profile_changes_with_context()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_logs (
      action, user_id, entity_id, entity_type, new_values
    )
    VALUES (
      'profile_created', 
      NEW.id, 
      NEW.id::text, 
      'profile',
      jsonb_build_object(
        'username', NEW.username,
        'full_name', NEW.full_name,
        'website', NEW.website,
        'avatar_url', NEW.avatar_url
      )
    );
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    -- Only log if there are actual changes
    IF NEW.username != OLD.username OR 
       NEW.full_name != OLD.full_name OR 
       NEW.website != OLD.website OR 
       NEW.avatar_url != OLD.avatar_url THEN
      INSERT INTO public.audit_logs (
        action, user_id, entity_id, entity_type, old_values, new_values
      )
      VALUES (
        'profile_updated', 
        NEW.id, 
        NEW.id::text, 
        'profile',
        jsonb_build_object(
          'username', OLD.username,
          'full_name', OLD.full_name,
          'website', OLD.website,
          'avatar_url', OLD.avatar_url
        ),
        jsonb_build_object(
          'username', NEW.username,
          'full_name', NEW.full_name,
          'website', NEW.website,
          'avatar_url', NEW.avatar_url
        )
      );
    END IF;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_logs (
      action, user_id, entity_id, entity_type, old_values
    )
    VALUES (
      'profile_deleted', 
      OLD.id, 
      OLD.id::text, 
      'profile',
      jsonb_build_object(
        'username', OLD.username,
        'full_name', OLD.full_name,
        'website', OLD.website,
        'avatar_url', OLD.avatar_url
      )
    );
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_public_submission(submission_id bigint, name text, phone text, vehicle_type text, budget_from real, budget_to real, ref text DEFAULT NULL::text, ip_address text DEFAULT NULL::text, user_agent text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.audit_logs (
    action,
    entity_id,
    entity_type,
    new_values,
    ip_address,
    user_agent,
    submitter_name
  )
  VALUES (
    'public_submission_created',
    submission_id::TEXT,
    'submission',
    jsonb_build_object(
      'name', name,
      'phone', phone,
      'vehicle_type', vehicle_type,
      'budget_range', format('%s-%s', budget_from, budget_to),
      'ref', ref
    ),
    ip_address,
    user_agent,
    name  -- Store the submitter's name directly
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_status_changes()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  user_id UUID := public.get_auth_user_id();
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_logs (
      action, 
      user_id, 
      entity_id, 
      entity_type,
      new_values
    )
    VALUES (
      'status_created', 
      user_id,
      NEW.id::text,
      'status',
      jsonb_build_object('name', NEW.name)
    );
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO public.audit_logs (
      action, 
      user_id, 
      entity_id, 
      entity_type,
      old_values,
      new_values
    )
    VALUES (
      'status_updated', 
      user_id,
      NEW.id::text,
      'status',
      jsonb_build_object('name', OLD.name),
      jsonb_build_object('name', NEW.name)
    );
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_logs (
      action, 
      user_id, 
      entity_id, 
      entity_type,
      old_values
    )
    VALUES (
      'status_deleted', 
      user_id,
      OLD.id::text,
      'status',
      jsonb_build_object('name', OLD.name)
    );
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_submission_changes()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  user_id UUID := public.get_auth_user_id();
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_logs (
      action, 
      user_id, 
      entity_id, 
      entity_type,
      new_values,
      ip_address,
      user_agent,
      submitter_name
    )
    VALUES (
      'submission_created', 
      user_id, -- Can be NULL for unauthenticated submissions
      NEW.id::text,
      'submission',
      jsonb_build_object(
        'name', NEW.name,
        'phone', NEW.phone,
        'vehicle_type', NEW.vehicle_type,
        'budget_range', format('%s-%s', NEW.budget_from, NEW.budget_to),
        'ref', NEW.ref
      ),
      NULLIF(current_setting('request.headers.x-forwarded-for', true), ''),
      NULLIF(current_setting('request.headers.user-agent', true), ''),
      NEW.name -- Store the submitter's name
    );
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    -- Handle status change
    IF NEW.status_id IS DISTINCT FROM OLD.status_id THEN
      INSERT INTO public.audit_logs (
        action, 
        user_id, 
        entity_id, 
        entity_type,
        old_values,
        new_values
      )
      VALUES (
        'submission_status_changed', 
        user_id, -- This should be an authenticated action
        NEW.id::text,
        'submission',
        jsonb_build_object('status_id', OLD.status_id),
        jsonb_build_object('status_id', NEW.status_id)
      );
    END IF;
    
    -- Handle assignment change
    IF NEW.assigned_user_id IS DISTINCT FROM OLD.assigned_user_id THEN
      INSERT INTO public.audit_logs (
        action, 
        user_id, 
        entity_id, 
        entity_type,
        old_values,
        new_values
      )
      VALUES (
        'submission_assignment_changed', 
        user_id, -- This should be an authenticated action
        NEW.id::text,
        'submission',
        jsonb_build_object('assigned_user_id', OLD.assigned_user_id),
        jsonb_build_object('assigned_user_id', NEW.assigned_user_id)
      );
    END IF;
    
    -- Handle other updates
    IF NEW.phone IS DISTINCT FROM OLD.phone OR 
       NEW.name IS DISTINCT FROM OLD.name OR 
       NEW.budget_from IS DISTINCT FROM OLD.budget_from OR 
       NEW.budget_to IS DISTINCT FROM OLD.budget_to OR 
       NEW.vehicle_type IS DISTINCT FROM OLD.vehicle_type OR
       NEW.ref IS DISTINCT FROM OLD.ref THEN
      INSERT INTO public.audit_logs (
        action, 
        user_id, 
        entity_id, 
        entity_type,
        old_values,
        new_values
      )
      VALUES (
        'submission_updated', 
        user_id, -- This should be an authenticated action
        NEW.id::text,
        'submission',
        jsonb_build_object(
          'name', OLD.name,
          'phone', OLD.phone,
          'vehicle_type', OLD.vehicle_type,
          'budget_from', OLD.budget_from,
          'budget_to', OLD.budget_to,
          'ref', OLD.ref
        ),
        jsonb_build_object(
          'name', NEW.name,
          'phone', NEW.phone,
          'vehicle_type', NEW.vehicle_type,
          'budget_from', NEW.budget_from,
          'budget_to', NEW.budget_to,
          'ref', NEW.ref
        )
      );
    END IF;
    
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_logs (
      action, 
      user_id, 
      entity_id, 
      entity_type,
      old_values
    )
    VALUES (
      'submission_deleted', 
      user_id, -- This should be an authenticated action
      OLD.id::text,
      'submission',
      jsonb_build_object(
        'name', OLD.name,
        'phone', OLD.phone,
        'vehicle_type', OLD.vehicle_type,
        'budget_range', format('%s-%s', OLD.budget_from, OLD.budget_to)
      )
    );
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_submission_tag_changes()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  user_id UUID := public.get_auth_user_id();
  tag_name TEXT;
BEGIN
  IF TG_OP = 'INSERT' THEN
    -- Get tag name for better logging
    SELECT name INTO tag_name FROM public.tags WHERE id = NEW.tag_id;
    
    INSERT INTO public.audit_logs (
      action, 
      user_id, 
      entity_id, 
      entity_type,
      new_values
    )
    VALUES (
      'tag_added_to_submission', 
      user_id,
      format('%s-%s', NEW.submission_id, NEW.tag_id),
      'submission_tag',
      jsonb_build_object(
        'submission_id', NEW.submission_id,
        'tag_id', NEW.tag_id,
        'tag_name', tag_name
      )
    );
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    -- Get tag name for better logging
    SELECT name INTO tag_name FROM public.tags WHERE id = OLD.tag_id;
    
    INSERT INTO public.audit_logs (
      action, 
      user_id, 
      entity_id, 
      entity_type,
      old_values
    )
    VALUES (
      'tag_removed_from_submission', 
      user_id,
      format('%s-%s', OLD.submission_id, OLD.tag_id),
      'submission_tag',
      jsonb_build_object(
        'submission_id', OLD.submission_id,
        'tag_id', OLD.tag_id,
        'tag_name', tag_name
      )
    );
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_tag_changes()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  user_id UUID := public.get_auth_user_id();
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_logs (
      action, 
      user_id, 
      entity_id, 
      entity_type,
      new_values
    )
    VALUES (
      'tag_created', 
      user_id,
      NEW.id::text,
      'tag',
      jsonb_build_object(
        'name', NEW.name,
        'hex', NEW.hex
      )
    );
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO public.audit_logs (
      action, 
      user_id, 
      entity_id, 
      entity_type,
      old_values,
      new_values
    )
    VALUES (
      'tag_updated', 
      user_id,
      NEW.id::text,
      'tag',
      jsonb_build_object(
        'name', OLD.name,
        'hex', OLD.hex
      ),
      jsonb_build_object(
        'name', NEW.name,
        'hex', NEW.hex
      )
    );
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_logs (
      action, 
      user_id, 
      entity_id, 
      entity_type,
      old_values
    )
    VALUES (
      'tag_deleted', 
      user_id,
      OLD.id::text,
      'tag',
      jsonb_build_object(
        'name', OLD.name,
        'hex', OLD.hex
      )
    );
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$function$
;

create or replace view "public"."referrers" as  SELECT DISTINCT submissions.ref
   FROM submissions;


grant delete on table "public"."audit_logs" to "anon";

grant insert on table "public"."audit_logs" to "anon";

grant references on table "public"."audit_logs" to "anon";

grant select on table "public"."audit_logs" to "anon";

grant trigger on table "public"."audit_logs" to "anon";

grant truncate on table "public"."audit_logs" to "anon";

grant update on table "public"."audit_logs" to "anon";

grant delete on table "public"."audit_logs" to "authenticated";

grant insert on table "public"."audit_logs" to "authenticated";

grant references on table "public"."audit_logs" to "authenticated";

grant select on table "public"."audit_logs" to "authenticated";

grant trigger on table "public"."audit_logs" to "authenticated";

grant truncate on table "public"."audit_logs" to "authenticated";

grant update on table "public"."audit_logs" to "authenticated";

grant delete on table "public"."audit_logs" to "service_role";

grant insert on table "public"."audit_logs" to "service_role";

grant references on table "public"."audit_logs" to "service_role";

grant select on table "public"."audit_logs" to "service_role";

grant trigger on table "public"."audit_logs" to "service_role";

grant truncate on table "public"."audit_logs" to "service_role";

grant update on table "public"."audit_logs" to "service_role";

grant delete on table "public"."profiles" to "anon";

grant insert on table "public"."profiles" to "anon";

grant references on table "public"."profiles" to "anon";

grant select on table "public"."profiles" to "anon";

grant trigger on table "public"."profiles" to "anon";

grant truncate on table "public"."profiles" to "anon";

grant update on table "public"."profiles" to "anon";

grant delete on table "public"."profiles" to "authenticated";

grant insert on table "public"."profiles" to "authenticated";

grant references on table "public"."profiles" to "authenticated";

grant select on table "public"."profiles" to "authenticated";

grant trigger on table "public"."profiles" to "authenticated";

grant truncate on table "public"."profiles" to "authenticated";

grant update on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";

grant delete on table "public"."statuses" to "anon";

grant insert on table "public"."statuses" to "anon";

grant references on table "public"."statuses" to "anon";

grant select on table "public"."statuses" to "anon";

grant trigger on table "public"."statuses" to "anon";

grant truncate on table "public"."statuses" to "anon";

grant update on table "public"."statuses" to "anon";

grant delete on table "public"."statuses" to "authenticated";

grant insert on table "public"."statuses" to "authenticated";

grant references on table "public"."statuses" to "authenticated";

grant select on table "public"."statuses" to "authenticated";

grant trigger on table "public"."statuses" to "authenticated";

grant truncate on table "public"."statuses" to "authenticated";

grant update on table "public"."statuses" to "authenticated";

grant delete on table "public"."statuses" to "service_role";

grant insert on table "public"."statuses" to "service_role";

grant references on table "public"."statuses" to "service_role";

grant select on table "public"."statuses" to "service_role";

grant trigger on table "public"."statuses" to "service_role";

grant truncate on table "public"."statuses" to "service_role";

grant update on table "public"."statuses" to "service_role";

grant delete on table "public"."submission_tags" to "anon";

grant insert on table "public"."submission_tags" to "anon";

grant references on table "public"."submission_tags" to "anon";

grant select on table "public"."submission_tags" to "anon";

grant trigger on table "public"."submission_tags" to "anon";

grant truncate on table "public"."submission_tags" to "anon";

grant update on table "public"."submission_tags" to "anon";

grant delete on table "public"."submission_tags" to "authenticated";

grant insert on table "public"."submission_tags" to "authenticated";

grant references on table "public"."submission_tags" to "authenticated";

grant select on table "public"."submission_tags" to "authenticated";

grant trigger on table "public"."submission_tags" to "authenticated";

grant truncate on table "public"."submission_tags" to "authenticated";

grant update on table "public"."submission_tags" to "authenticated";

grant delete on table "public"."submission_tags" to "service_role";

grant insert on table "public"."submission_tags" to "service_role";

grant references on table "public"."submission_tags" to "service_role";

grant select on table "public"."submission_tags" to "service_role";

grant trigger on table "public"."submission_tags" to "service_role";

grant truncate on table "public"."submission_tags" to "service_role";

grant update on table "public"."submission_tags" to "service_role";

grant delete on table "public"."submissions" to "anon";

grant insert on table "public"."submissions" to "anon";

grant references on table "public"."submissions" to "anon";

grant select on table "public"."submissions" to "anon";

grant trigger on table "public"."submissions" to "anon";

grant truncate on table "public"."submissions" to "anon";

grant update on table "public"."submissions" to "anon";

grant delete on table "public"."submissions" to "authenticated";

grant insert on table "public"."submissions" to "authenticated";

grant references on table "public"."submissions" to "authenticated";

grant select on table "public"."submissions" to "authenticated";

grant trigger on table "public"."submissions" to "authenticated";

grant truncate on table "public"."submissions" to "authenticated";

grant update on table "public"."submissions" to "authenticated";

grant delete on table "public"."submissions" to "service_role";

grant insert on table "public"."submissions" to "service_role";

grant references on table "public"."submissions" to "service_role";

grant select on table "public"."submissions" to "service_role";

grant trigger on table "public"."submissions" to "service_role";

grant truncate on table "public"."submissions" to "service_role";

grant update on table "public"."submissions" to "service_role";

grant delete on table "public"."tags" to "anon";

grant insert on table "public"."tags" to "anon";

grant references on table "public"."tags" to "anon";

grant select on table "public"."tags" to "anon";

grant trigger on table "public"."tags" to "anon";

grant truncate on table "public"."tags" to "anon";

grant update on table "public"."tags" to "anon";

grant delete on table "public"."tags" to "authenticated";

grant insert on table "public"."tags" to "authenticated";

grant references on table "public"."tags" to "authenticated";

grant select on table "public"."tags" to "authenticated";

grant trigger on table "public"."tags" to "authenticated";

grant truncate on table "public"."tags" to "authenticated";

grant update on table "public"."tags" to "authenticated";

grant delete on table "public"."tags" to "service_role";

grant insert on table "public"."tags" to "service_role";

grant references on table "public"."tags" to "service_role";

grant select on table "public"."tags" to "service_role";

grant trigger on table "public"."tags" to "service_role";

grant truncate on table "public"."tags" to "service_role";

grant update on table "public"."tags" to "service_role";

create policy "Public profiles are viewable by everyone."
on "public"."profiles"
as permissive
for select
to public
using (true);


create policy "Users can insert their own profile."
on "public"."profiles"
as permissive
for insert
to public
with check ((( SELECT auth.uid() AS uid) = id));


create policy "Users can update own profile."
on "public"."profiles"
as permissive
for update
to public
using ((( SELECT auth.uid() AS uid) = id));


CREATE TRIGGER profile_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION log_profile_changes();

CREATE TRIGGER status_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON public.statuses FOR EACH ROW EXECUTE FUNCTION log_status_changes();

CREATE TRIGGER submission_tag_audit_trigger AFTER INSERT OR DELETE ON public.submission_tags FOR EACH ROW EXECUTE FUNCTION log_submission_tag_changes();

CREATE TRIGGER submission_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON public.submissions FOR EACH ROW EXECUTE FUNCTION log_submission_changes();

CREATE TRIGGER tag_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON public.tags FOR EACH ROW EXECUTE FUNCTION log_tag_changes();


